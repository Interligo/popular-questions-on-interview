### Сборник теоретических вопросов по Питону

***

* PEP8 - соглашение о том, как писать код для языка python.

***

* Основные признаки Python:

1. Это интерпретируемый язык, что снижает скорость исполнения программы, но исходный код выполняется методом интерпретации, без компиляции;

2. Это объектно-ориентированный язык, что позволяет реализовать следующие функции - инкапсуляция, абстракция, полиморфизм, наследование;

3. Динамическая типизация данных - переменная связывается с типом в момент присваивания значения, а не в момент объявления переменной. Таким образом, в различных участках программы одна и та же переменная может принимать значения разных типов. Данный тип типизации может привести к появлению ошибок исполнения (runtime errors).

***

* Ключевое слово 'def':

С помощью этого ключевого слова в Python можно создавать новые объекты-функции и присваивает им имена. 

`def` - это исполняемая инструкция, т.е. пока интерпретатор не добрался и не исполнил эту инструкцию - функции не существует.

***

* Разница между 'return' & 'yield':

`return` - передает объект результата вызывающей программе (пока функция не завершит работу и не вернет управление, вызывающая её программа приостанавливает свою работу).

`yield` - передает объект результата вызывающей программе и запоминает, где был произведен возврат.

***

* Области видимости в Python.

Python содержит три разных типа области видимости:

1. Локальная область видимости - все назначения выполняются в локальной области по умолчанию. 

2. Глобальная область видимости - чтобы иметь возможность использовать некоторое значение в любой части программы, следует объявить глобальную переменную. Таким образом, получение доступа к глобальной переменной осуществляется из любой части кода, благодаря глобальной области видимости подобного объекта.

3. Нелокальная область видимости - если требуется вызывать не глобальную переменную, а переменную которая была определена во внешнем методе, являясь при этом локальной для другого пространства имен, находящегося на уровень выше, в таком случае на помощь приходят нелокальные переменные.

***

* Ключевые слова 'global' & 'nonlocal':

`global` - объявляет переменные, глобальные для модуля, без присваивания им значений.

`nonlocal` - объявляет переменные, находящиеся в области видимости объемлющей функции, без присваивания им значений.

***

* Подробно о принципах ООП:

`Абстракция` — это выделение основных, наиболее значимых характеристик объекта и игнорирование второстепенных. К примеру, говоря "ноутбук" не нужно ничего конкретизировать, все и так всё понимают;

`Полиморфизм` — подразумевает возможность нескольких реализаций одной идеи. К примеру, есть класс "Персонаж", у которого есть метод "Атаковать": у воина это будет удар мечом, а волшебника использование заклинания. В сущности, все эти методы есть атака, но в программном коде они реализованы по-разному;

`Наследование` — способность одного класса расширять понятие другого, и главный механизм повторного использования кода в ООП. К примеру, класс "Грузовик" можно унаследовать от класса "Автотранспорт" и тогда грузовик, в дополнение к своей грузоподъемности, сразу будет обладать всеми характеристиками автотранспорта;

`Инкапсуляция` — блокирует доступ к деталям сложной концепции;

`DRY (Don’t repeat yourself)` - избегайте повторного написания кода, вынося в абстракции часто используемые задачи и данные;

`Принцип единственной обязанности` - для каждого класса должно быть определено единственное назначение; 

`Принцип открытости/закрытости` - программные сущности должны быть открыты для расширения, но закрыты для изменений;

`Принцип подстановки Барбары Лисков` - методы, использующие некий тип, должны иметь возможность использовать его подтипы, не зная об этом;

`Принцип разделения интерфейсов` - предпочтительнее разделять интерфейсы на более мелкие тематические, чтобы реализующие их классы не были вынуждены определять методы, которые непосредственно в них не используются;

`Принцип инверсии зависимостей` - система должна конструироваться на основе абстракций «сверху вниз»: не абстракции должны формироваться на основе деталей, а детали должны формироваться на основе абстракций.

***

* Что такое тернатрный оператор?

`[если верно] if [выражение] else [если неверно]`

То есть, когда выражение верное (True), то исполняется код [если верно]. В остальных случаях исполняется код [если неверно].

***

* Что такое interpreter prompt (приглашение интерпретатора):

```python
>>>
```

***

* Для чего нужен pass (pass statement)?

Если необходимо иметь синтаксический корректный код, то можно воспользоваться "заглушкой" pass. В таком случае функция ничего не делает, но и не показывает никаких ошибок.

```python
def func(*args):
    pass
```

***

* Структуры данных в Питоне (mutable/immutable):

**mutable (изменяемые)** - list, dict, set 

**immutable (неизменяемые)** – tuple, frozenset + строки, числа

***

* Способы форматирования строк:

Форматирование с помощью оператора `%`: 

```python
print('string number %s, or simply %d' % (string, integer))
```

Форматирование с помощью метода str.format:

```python
print('string number {}, or simply {}'.format(string, integer))
```

Форматирование с помощью f-string:

```python
print(f'string number {string}, or simply {integer}')
```

***

* Операции над множествами.

1. Объединение:

Слияние элементов обоих множеств.

```python
union = set_1 | set_2
```

2. Пересечение:

Поиск элементов, входящих в оба множества.

```python
intersection = set_1 & set_2
```

3. Разность:

Исключение из одного множества элементов, присутствующих в другом множестве.

```python
difference = set_1 - set_2
```

***

* В чем отличие поверхностного копирования от глубокого?

Поверхностное копирование создает ссылку на этот же объект, поэтому в этой копии будут отражаться все изменения оригинального объекта.

Глубокое копирование создает полную копию объекта, поскольку создается отдельный объект, то изменения оригинального объекта не будут отражены.

***

* Где будет быстрее поиск, а где перебор и почему: dict, list, set, tuple?

Средняя временная сложность поиска в множествах и словарях соответствует O(1), в случае последовательностей O(n). Кортежи – это неизменяемый тип, поэтому они могут давать выигрыш в скорости перед списками.

***

* Что такое и как работает хэш-таблица (словарь)?

Хэш-функция представляет собой функцию, которая получает на вход строку и возвращает число. Такая функция неизменно связывает название с одним индексом.

Это тип структуры данных, в которой адрес или значение индекса элемента данных генерируются из хеш-функции. В хэш-таблице хранятся пары ключ-значение, но ключ генерируется с помощью функции хеширования.

В Python хэш-таблицами являются словари.

***

* Коллизии в хэш-таблицах

Коллизия - это ситуация, когда двум ключам назначается один индекс (один элемент массива). Хорошая хэш-функция создает минимальное количество коллизий :)

***

* Используются ли хэш-таблицы как кэш?

Кэширование - это стандартный способ ускорения работы. Все крупные веб-сайты используют кеширование, а эти данные хранятся в хэше. 

Когда пользователь направляет запрос на сайт, то сайт сначала проверяет, хранится ли эта странице в кэше. Сервер будет выполнять работу только в случае, если данная страница не находится в кэше. 

***

* Обозначение бесконечности в Python

`float('inf')`

***

* Что делает функция id?

Возвращает идентификатор переданного объекта, уникальный на время его существования.

***

* В чем разница между del и remove?

`del` позволяет удалять элементы под конкретным индексом, а `remove` позволяет удалять элементы на основе их значения.

***

* Как получить список всех атрибутов объекта?

В простейшем виде с помощью функции `dir`.

***

* Что такое анонимные функции?

Это особый вид функций, которые объявляются в месте использования и не получают уникального идентификатора для доступа к ним. 
Анонимные функции создаются при помощи лямбда-выражений. 

```python
lambda x: x + 1
```

***

* Декораторы

Это, по сути, "обёртки", которые дают нам возможность изменить поведение функции, не изменяя её код.

```python
def my_decorator(function_to_decorate):
    def the_wrapper_around_the_original_function():
        print("Я - код, который отработает до вызова функции")
        function_to_decorate()
        print("А я - код, срабатывающий после")
    return the_wrapper_around_the_original_function


@my_decorator
def stand_alone_function():
    print("Я простая одинокая функция, ты ведь не посмеешь меня изменять?")
    
    
stand_alone_function()  

# Я - код, который отработает до вызова функции
# Я простая одинокая функция, ты ведь не посмеешь меня изменять?
# А я - код, срабатывающий после
```

Декораторы в Python — это просто синтаксический сахар для конструкций вида: `another_stand_alone_function = my_shiny_new_decorator(another_stand_alone_function`.

```python
def decorator_passing_arbitrary_arguments(function_to_decorate):
    # Данная "обёртка" принимает любые аргументы
    def wrapper_accepting_arbitrary_arguments(*args, **kwargs):
        print("Передали ли мне что-нибудь?")
        print(args)
        print(kwargs)
        function_to_decorate(*args, **kwargs)
    return wrapper_accepting_arbitrary_arguments


@decorator_passing_arbitrary_arguments
def function_with_no_argument():
    print("Python is cool, no argument here.")


function_with_no_argument()

# Передали ли мне что-нибудь?
# ()
# {}
# Python is cool, no argument here.


@decorator_passing_arbitrary_arguments
def function_with_arguments(a, b, c):
    print(a, b, c)


function_with_arguments(3, 2, 1)

# Передали ли мне что-нибудь?
# (3, 2, 1)
# {}
# 3 2 1
```

***

* Декоратор @property

Этот декоратор может быть использован для определения методов в классе, которые действуют как атрибуты.

```python
class Order:
    def __init__(self, name, price, quantity):
        self._name = name
        self.price = price
        self._quantity = quantity
        
    @property
    def quantity(self):
        return self._quantity
        
    @quantity.setter
    def quantity(self, value):
        if value < 0:
            raise ValueError('Cannot be negative.')
        self._quantity = value


apple_order.quantity = -10
# ValueError: Cannot be negative
```

***

* Метаклассы

В Python классы являются объектами, поэтому они сами должны чем-то генерироваться. Эти конструкции представляют собой своеобразные «классы классов» и называются метаклассами. Примером встроенного метакласса является type.

***

* Встроенные функции dir, help, hasattr, getattr

`dir` - возвращает имена переменных, доступные в локальной области, либо атрибуты указанного объекта в алфавитном порядке.

`help` - показывает строку документации и справку для ее аргумента.

`hasattr` - возвращает флаг, указывающий на то, содержит ли объект указанный атрибут.

`getattr` - возвращает значение атрибута объекта.

***

* Методы (public, protected, private)

Все компоненты класса Python по умолчанию являются открытыми (public). Для защищенных (protected) методов по соглашению Python добавляется префикс одиночного подчеркивания, для закрытых (private) методов – префикс двойного подчеркивания.

***

* В чем разница между одинарным (_) и двойным (__) подчеркиванием?

Одинарным подчеркиванием задаются частные переменные, функции, методы и классы, т.е. это **protected**. Все эти объекты будут проигнорированы при импорте с помощью `from module import *`.

Двойное подчеркивание применяется для искажения имен атрибутов в классе (вызвать такой метод стандартным образом не получится), т.е. это **private**. В сообществе Python двойные символы подчеркивания часто называют «дандерами» (dunders — это сокращение от англ. double underscores).

***

* Методы (static, class)

Базовые декораторы classmethod, staticmethod используются для методов, определённых внутри классов. 

`@staticmethod` - используется для создания метода, который ничего не знает о классе или экземпляре, через который он был вызван. Он просто получает переданные аргументы, без неявного первого аргумента (self), и его определение неизменяемо через наследование. 
Проще говоря, staticmethod — это вроде обычной функции, определенной внутри класса, которая не имеет доступа к экземпляру, поэтому ее можно вызывать без создания экземпляра класса.

```python
class Myclass():
    @staticmethod
    def staticmethod():
        print('Static method called')
  
  
# Вызываем метод без создания экземпляра класса
Myclass.staticmethod()  

# Вызов метода из экземпляра класса тоже возможен
my_obj = Myclass()
my_obj.staticmethod()

# Результат
Static method called
```

`@classmethod` - это метод, который получает класс в качестве неявного первого аргумента (cls), точно так же, как обычный метод экземпляра получает экземпляр (self). Это означает, что возможно использовать класс и его свойства внутри этого метода, а не конкретного экземпляра.
Проще говоря, classmethod — это обычный метод класса, имеющий доступ ко всем атрибутам класса, через который он был вызван. Следовательно, classmethod — это метод, который привязан к классу, а не к экземпляру класса.

```python
class MyClass:
    @classmethod
    def classmethod(cls):
        print('Class method called')
        
# Вызываем метод без создания экземпляра класса        
MyClass.classmethod()

# Результат
Class method called
```

classmethod используется, когда нужно получить методы, не относящиеся к какому-либо конкретному экземпляру, но тем не менее, каким-то образом привязанные к классу. Самое интересное в них то, что их можно переопределить дочерними классами.

```python
class MyClass():    
    TOTAL_OBJECTS=0
    
    def __init__(self):
        MyClass.TOTAL_OBJECTS = MyClass.TOTAL_OBJECTS + 1
       
    @classmethod
    def total_objects(cls):
        print("Total objects: ", cls.TOTAL_OBJECTS)
        
        
# Создаем объекты        
my_obj1 = MyClass()
my_obj2 = MyClass()
my_obj3 = MyClass()

# Вызываем classmethod 
MyClass.total_objects()

# Результат
Total objects: 3
```

**Резюме**: `@classmethod` используется в суперклассе для определения того, как метод должен вести себя, когда он вызывается разными дочерними классами. В то время как `@staticmethod` используется, когда мы хотим вернуть одно и то же, независимо от вызываемого дочернего класса.

***

* Что такое магические методы?

Специальные методы, обрамленные двумя подчеркиваниями. Магические методы представляют простой способ заставить объекты вести себя аналогично встроенным типам. 
Это, в частности, позволяет стандартизировать поведение базовых операторов с экземплярами класса.

***

* Что такое дескриптор?

Дескриптор – атрибут объекта, чьё поведение при доступе переопределяется методами `__get__`, `__set__` и `__delete__`. Если определен хотя бы один из этих методов, объект становится дескриптором.

О дескрипторах чуть проще: в Python существует три варианта доступа к атрибуту. Допустим у нас есть атрибут `a` объекта `obj`:

Получим значение атрибута - `some_variable = obj.a`

Изменим его значение - `obj.a = 'new value'`

Удалим атрибут - `del obj.a`

Python позволяет перехватить выше упомянутые попытки доступа к атрибуту и переопределить связанное с этим доступом поведение. Это реализуется через механизм протокола дескрипторов.

```python
class NonNegative:
    def __get__(self, instance, owner):
        return instance.__dict__[self.name]
        
    def __set__(self, instance, value):
        if value < 0:
            raise ValueError('Cannot be negative.')
        instance.__dict__[self.name] = value
        
    def __set_name__(self, owner, name):
        self.name = name
        
        
class Order:
    price = NonNegative()
    quantity = NonNegative()
    
    def __init__(self, name, price, quantity):
        self._name = name
        self.price = price
        self.quantity = quantity
        
    def total(self):
        return self.price * self.quantity
        
        
apple_order = Order('apple', 1, 10)
apple_order.total()
# 10
apple_order.price = -10
# ValueError: Cannot be negative
apple_order.quantity = -10
# ValueError: Cannot be negative
```

***

* В чем отличие 'new' от 'init'?

Метод `__new__` используется, когда нужно управлять процессом создания нового экземпляра, а `__init__` – когда контролируется его инициализация. Поэтому new возвращает новый экземпляр класса, а init – ничего.

Если необходимо переопределить new, то сделать это нужно следующим образом:

```python
class Speedometer:
    def __init__(self, max_speed, units):
        print('Method __init__ ...')
        self.max_speed = max_speed
        self.units = units
    
    def __new__(cls, max_speed, units):
        print('Method __new__ ...')
        if max_speed > 250:
            return None
        return super().__new__(cls)


s1 = Speedometer(100, 'km')
# Method __new__ ...
# Method __init__ ...
print(s1.max_speed)
# 100

s2 = Speedometer(300, 'km')
# Method __new__ ...
print(s2 is None)
# True
```

***

* Для чего в Python используются слоты?

Магический атрибут `__slots__` позволяет задать ограниченный набор атрибутов, которыми будет обладать экземпляр класса. За счет такого ограничения можно повысить скорость работы при доступе к атрибутам и сэкономить место в памяти.

***

* Метод super

`super` - это встроенная функция, которая возвращает прокси-объект, который делегирует вызовы методов классу-родителю (или собрату) текущего класса.

Основное ее применение и польза – получения доступа из класса наследника к методам класса-родителя в том случае, если наследник переопределил эти методы.

```python
class Base:
    def price(self):
        return 10
        
        
class InterFoo(Base):
    def price(self):
        return super().price() * 1.1
        
        
class Discount(InterFoo):
    def price(self):
        return super().price() * 0.8
```

***

* В чем отличие `(i for i in arr)` от `[i for i in arr]`?

Слева – выражение-генератор, справа – генератор списка (list comprehension). 
Выражение-генератор создает список в памяти по мере необходимости, а генератор списка - сразу создает его целиком.

***

* В чем отличие генератора от итератора?

**Итератор** является более общей концепцией, чем генератор, и представляет собой **любой объект, класс которого имеет методы __next__ и __iter__**. 

```python
list_of_numbers = [1, 2, 3]

numbers_iterator = iter(list_of_numbers)

next(numbers_iterator)
# 1
```

При каждом новом вызове, функция отдаёт один элемент. Если же в итераторе элементов больше не осталось, то функция `next()` породит исключение `StopIteration`.

**Генератор** – это итератор, который обычно создается путем вызова функции, **содержащей не менее одного оператора yield**. 
Это ключевое слово действует аналогично return, но возвращает объект-генератор.

Генератор — это объект, который сразу при создании не вычисляет значения всех своих элементов. Он хранит в памяти только последний вычисленный элемент, правило перехода к следующему и условие, при котором выполнение прерывается. Вычисление следующего значения происходит лишь при выполнении метода next(). Предыдущее значение при этом теряется.

```python
a = (i**2 for i in range(1,5))
for i in a:
    print(i)
```

Чтобы постоянно не вызывать метод `next(a)`, можно использовать цикл. В таком случае, метод `next()` будет вызывать неявно. Когда весь цикл будет пройден, то произойдет исключение `StopIteration`, но в консоль оно не будет выведено. Чтобы снова воспользоваться генератором, необходимо создать его заново.

Пример практической задачи: на сервере есть огромный журнал событий log.txt, в котором хранятся сведения о работе какой-то системы за год. Из него нужно выбрать и обработать для статистики данные об ошибках — строки, содержащие слово error.

```python
with open("path\log.txt", "r") as log_file:
     err_gen = (st for st in log_file if "error" in st)
     for item in err_gen:
         <обработка строки item>  
```

Таким образом, благодаря поточной обработке данных с использованием объекта-генератора, мы не получим переполнение памяти, поскольку в каждый момент времени в памяти находится только одна строка (обработанная строка стирается из памяти, а следующая записывается и обрабатывается, так до конца цикла).

Функцию-генератор можно создать следующим образом:

```python
def digits_gen(k):
    start = 1
    for n in range(1, k):
    yield n**2 + start
    start += 1
```

Кроме метода `next()` у генераторов есть ещё и `close()` - останавливает выполнение генератора, `throw()` - генератор бросает исключение, `send()` - позволяет отправлять значения генератору.

***

* Что такое list/dict comprehension?

**List comprehension** - это выражение, которое преобразует итерируемый объект в список. То есть, последовательность элементов преобразуется и добавляется в новый список.

```python
# List comprehension
vlans = [f'vlan {num}' for num in range(10,16)]

# Эквивалентно
vlans = []
for num in range(10,16):
    vlans.append(f'vlan {num}')

# Результат идентичен
print(vlans)
['vlan 10', 'vlan 11', 'vlan 12', 'vlan 13', 'vlan 14', 'vlan 15']
```

**Dict comprehension** - аналогичны генераторам списков, но они используются для создания словарей.

```python
# Dict comprehension
d = {num: num**2 for num in range(1, 11)}

# Эквивалентно
d = {}
for num in range(1, 11):
    d[num] = num**2

# Результат идентичен
print(d)
{1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81, 10: 100}
```

***

* Что такое GIL?

Python Global Interpreter Lock (GIL) — это своеобразная блокировка, позволяющая только одному потоку управлять интерпретатором Python. Это означает, что в любой момент времени будет выполняться только один конкретный поток. Поскольку GIL позволяет работать только одному потоку даже в многопоточном приложении, он заработал репутацию «печально известной» функции.

***

* Что такое MRO?

MRO – сокращение от method resolution order. То есть это способ разрешения проблемы множественного наследования классов. 

***

* Threading vs Multiprocessing?

Модули – это subprocess и threading. Использование нескольких процессов аналогично использованию нескольких независимых программ, обмен данными организован через каналы. Если приложение должно выполнять несколько задач в одно и то же время, используются потоки (threads). В этом случае для ограничения доступа потоков к памяти в Python имеется блокировщик GIL.

***

* AsyncIO? В чём его особенность?

В отличие от потоков, в AsyncIO переключение между сопрограммами происходит лишь тогда, когда сопрограмма ожидает завершения внешней операции. 

***

* Что такое async/await, для чего они нужны и как их использовать?

`async`/`await` нужен для того, чтобы не блокировать поток выполнения на время ожидания какого-нибудь асинхронного события. Конструкция async/await превращает по сути процедуру в корутину (сопрограмму): она прекращает своё выполнение на время await, дожидается асинхронного события, и возобновляет работу.

***

* Что такое garbage collector (gc)?

Как только объекты больше не нужны (например, количество ссылок == 0), Python автоматически освобождает память из под них.

***

* Что такое контекстные менеджеры?

Контекстные менеджеры – это конструкции, которые упрощают работу с тем или иным интерфейсом (например, работу с файлами). Создаются они с помощью оператора **with**.

***
