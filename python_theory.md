### Сборник теоретических вопросов по Питону

* PEP8 - соглашение о том, как писать код для языка python.

* Основные признаки Python:

1. Это интерпретируемый язык, что снижает скорость исполнения программы, но исходный код выполняется методом интерпретации, без компиляции;

2. Это объектно-ориентированный язык, что позволяет реализовать следующие функции - инкапсуляция, абстракция, полиморфизм, наследование;

3. Динамическая типизация данных - переменная связывается с типом в момент присваивания значения, а не в момент объявления переменной. Таким образом, в различных участках программы одна и та же переменная может принимать значения разных типов. Данный тип типизации может привести к появлению ошибок исполнения (runtime errors).

* Подробно о принципах ООП:

`Абстракция` — это выделение основных, наиболее значимых характеристик объекта и игнорирование второстепенных. К примеру, говоря "ноутбук" не нужно ничего конкретизировать, все и так всё понимают;

`Полиморфизм` — подразумевает возможность нескольких реализаций одной идеи. К примеру, есть класс "Персонаж", у которого есть метод "Атаковать": у воина это будет удар мечом, а волшебника использование заклинания. В сущности, все эти методы есть атака, но в программном коде они реализованы по-разному;

`Наследование` — способность одного класса расширять понятие другого, и главный механизм повторного использования кода в ООП. К примеру, класс "Грузовик" можно унаследовать от класса "Автотранспорт" и тогда грузовик, в дополнение к своей грузоподъемности, сразу будет обладать всеми характеристиками автотранспорта;

`Инкапсуляция` — блокирует доступ к деталям сложной концепции;

`DRY (Don’t repeat yourself)` - избегайте повторного написания кода, вынося в абстракции часто используемые задачи и данные;

`Принцип единственной обязанности` - для каждого класса должно быть определено единственное назначение; 

`Принцип открытости/закрытости` - программные сущности должны быть открыты для расширения, но закрыты для изменений;

`Принцип подстановки Барбары Лисков` - методы, использующие некий тип, должны иметь возможность использовать его подтипы, не зная об этом;

`Принцип разделения интерфейсов` - предпочтительнее разделять интерфейсы на более мелкие тематические, чтобы реализующие их классы не были вынуждены определять методы, которые непосредственно в них не используются;

`Принцип инверсии зависимостей` - система должна конструироваться на основе абстракций «сверху вниз»: не абстракции должны формироваться на основе деталей, а детали должны формироваться на основе абстракций.

* Что такое тернатрный оператор?

`[если верно] if [выражение] else [если неверно]`

То есть, когда выражение верное (True), то исполняется код [если верно]. В остальных случаях исполняется код [если неверно].

* Что такое interpreter prompt (приглашение интерпретатора):

```python
>>>
```

* Для чего нужен pass (pass statement)?

Если необходимо иметь синтаксический корректный код, то можно воспользоваться "заглушкой" pass. В таком случае функция ничего не делает, но и не показывает никаких ошибок.

```python
def func(*args):
    pass
```

* Структуры данных в Питоне (mutable/immutable):

**mutable (изменяемые)** - list, dict, set 

**immutable (неизменяемые)** – tuple, frozenset + строки, числа

* В чем отличие поверхностного копирования от глубокого?

Поверхностное копирование создает ссылку на этот же объект, поэтому в этой копии будут отражаться все изменения оригинального объекта.

Глубокое копирование создает полную копию объекта, поскольку создается отдельный объект, то изменения оригинального объекта не будут отражены.

* Где будет быстрее поиск, а где перебор и почему: dict, list, set, tuple?

Средняя временная сложность поиска в множествах и словарях соответствует O(1), в случае последовательностей O(n). Кортежи – это неизменяемый тип, поэтому они могут давать выигрыш в скорости перед списками.

* Что такое и как работает хэш-таблица (словарь)?

Это тип структуры данных, в которой адрес или значение индекса элемента данных генерируются из хеш-функции. В хэш-таблице хранятся пары ключ-значение, но ключ генерируется с помощью функции хеширования.

* Что делает функция id?

Возвращает идентификатор переданного объекта, уникальный на время его существования.

* В чем разница между del и remove?

`del` позволяет удалять элементы под конкретным индексом, а `remove` позволяет удалять элементы на основе их значения.

* Как получить список всех атрибутов объекта?

В простейшем виде с помощью функции **dir**.

* Что такое анонимные функции?

Это особый вид функций, которые объявляются в месте использования и не получают уникального идентификатора для доступа к ним. 
Анонимные функции создаются при помощи лямбда-выражений. 

* Декораторы

Это, по сути, "обёртки", которые дают нам возможность изменить поведение функции, не изменяя её код.

* Метаклассы

В Python классы являются объектами, поэтому они сами должны чем-то генерироваться. Эти конструкции представляют собой своеобразные «классы классов» и называются метаклассами. Примером встроенного метакласса является type.

* Встроенные функции dir, help, hasattr, getattr

`dir` - возвращает имена переменных, доступные в локальной области, либо атрибуты указанного объекта в алфавитном порядке.

`help` - показывает строку документации и справку для ее аргумента.

`hasattr` - возвращает флаг, указывающий на то, содержит ли объект указанный атрибут.

`getattr` - возвращает значение атрибута объекта.

* Методы (public, protected, private)

Все компоненты класса Python по умолчанию являются открытыми (public). Для защищенных (protected) методов по соглашению Python добавляется префикс одиночного подчеркивания, для закрытых (private) методов – префикс двойного подчеркивания.

* В чем разница между одинарным (_) и двойным (__) подчеркиванием?

Одинарным подчеркиванием задаются частные переменные, функции, методы и классы, т.е. это **protected**. Все эти объекты будут проигнорированы при импорте с помощью `from module import *`.

Двойное подчеркивание применяется для искажения имен атрибутов в классе (вызвать такой метод стандартным образом не получится), т.е. это **private**.

* Методы (static, class)

Базовые декораторы classmethod, staticmethod используются для методов, определённых внутри классов. 
В метод класса первым аргументом передаётся класс. 
Аналогично метод экземпляра в первом аргументе получает сам экземпляр. 
Статичный метод используется в том случае, когда метод не имеет доступа к тому, что представляет собой класс или объект класса.

`@staticmethod` - используется для создания метода, который ничего не знает о классе или экземпляре, через который он был вызван. Он просто получает переданные аргументы, без неявного первого аргумента (self), и его определение неизменяемо через наследование. 
Проще говоря, staticmethod — это вроде обычной функции, определенной внутри класса, которая не имеет доступа к экземпляру, поэтому ее можно вызывать без создания экземпляра класса.

```python
class Myclass():
    @staticmethod
    def staticmethod():
        print('Static method called')
  
  
# Вызываем метод без создания экземпляра класса
Myclass.staticmethod()  

# Вызов метода из экземпляра класса тоже возможен
my_obj = Myclass()
my_obj.staticmethod()

# Результат
Static method called
```

`@classmethod` - это метод, который получает класс в качестве неявного первого аргумента (cls), точно так же, как обычный метод экземпляра получает экземпляр (self). Это означает, что возможно использовать класс и его свойства внутри этого метода, а не конкретного экземпляра.
Проще говоря, classmethod — это обычный метод класса, имеющий доступ ко всем атрибутам класса, через который он был вызван. Следовательно, classmethod — это метод, который привязан к классу, а не к экземпляру класса.

```python
class MyClass:
    @classmethod
    def classmethod(cls):
        print('Class method called')
        
# Вызываем метод без создания экземпляра класса        
MyClass.classmethod()

# Результат
Class method called
```

classmethod используется, когда нужно получить методы, не относящиеся к какому-либо конкретному экземпляру, но тем не менее, каким-то образом привязанные к классу. Самое интересное в них то, что их можно переопределить дочерними классами.

```python
class MyClass():    
    TOTAL_OBJECTS=0
    
    def __init__(self):
        MyClass.TOTAL_OBJECTS = MyClass.TOTAL_OBJECTS + 1
       
    @classmethod
    def total_objects(cls):
        print("Total objects: ", cls.TOTAL_OBJECTS)
        
        
# Создаем объекты        
my_obj1 = MyClass()
my_obj2 = MyClass()
my_obj3 = MyClass()

# Вызываем classmethod 
MyClass.total_objects()

# Результат
Total objects: 3
```

**Резюме**: `@classmethod` используется в суперклассе для определения того, как метод должен вести себя, когда он вызывается разными дочерними классами. В то время как `@staticmethod` используется, когда мы хотим вернуть одно и то же, независимо от вызываемого дочернего класса.

* Что такое магические методы?

Специальные методы, обрамленные двумя подчеркиваниями. Магические методы представляют простой способ заставить объекты вести себя аналогично встроенным типам. 
Это, в частности, позволяет стандартизировать поведение базовых операторов с экземплярами класса.

* Что такое дескриптор?

Дескриптор – атрибут объекта, чьё поведение при доступе переопределяется методами `__get__`, `__set__` и `__delete__`. Если определен хотя бы один из этих методов, объект становится дескриптором.

* В чем отличие new от init?

Метод `__new__` используется, когда нужно управлять процессом создания нового экземпляра, а `__init__` – когда контролируется его инициализация. Поэтому new возвращает новый экземпляр класса, а init – ничего.

* Для чего в Python используются слоты?

Магический атрибут `__slots__` позволяет задать ограниченный набор атрибутов, которыми будет обладать экземпляр класса. За счет такого ограничения можно повысить скорость работы при доступе к атрибутам и сэкономить место в памяти.

* В чем отличие `(i for i in arr)` от `[i for i in arr]`?

Слева – выражение-генератор, справа – генератор списка (list comprehension). 
Выражение-генератор создает список в памяти по мере необходимости, а генератор списка - сразу создает его целиком.

* В чем отличие генератора от итератора?

**Итератор** является более общей концепцией, чем генератор, и представляет собой **любой объект, класс которого имеет методы __next__ и __iter__**. 

**Генератор** – это итератор, который обычно создается путем вызова функции, **содержащей не менее одного оператора yield**. 
Это ключевое слово действует аналогично return, но возвращает объект-генератор.

* Что такое list/dict comprehension?

**List comprehension** - это выражение, которое преобразует итерируемый объект в список. То есть, последовательность элементов преобразуется и добавляется в новый список.

```python
# List comprehension
vlans = [f'vlan {num}' for num in range(10,16)]

# Эквивалентно
vlans = []
for num in range(10,16):
    vlans.append(f'vlan {num}')

# Результат идентичен
print(vlans)
['vlan 10', 'vlan 11', 'vlan 12', 'vlan 13', 'vlan 14', 'vlan 15']
```

**Dict comprehension** - аналогичны генераторам списков, но они используются для создания словарей.

```python
# Dict comprehension
d = {num: num**2 for num in range(1, 11)}

# Эквивалентно
d = {}
for num in range(1, 11):
    d[num] = num**2

# Результат идентичен
print(d)
{1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81, 10: 100}
```

* Что такое GIL?

Python Global Interpreter Lock (GIL) — это своеобразная блокировка, позволяющая только одному потоку управлять интерпретатором Python. Это означает, что в любой момент времени будет выполняться только один конкретный поток. Поскольку GIL позволяет работать только одному потоку даже в многопоточном приложении, он заработал репутацию «печально известной» функции.

* Что такое MRO?

MRO – сокращение от method resolution order. То есть это способ разрешения проблемы множественного наследования классов. 

* Threading vs Multiprocessing?

Модули – это subprocess и threading. Использование нескольких процессов аналогично использованию нескольких независимых программ, обмен данными организован через каналы. Если приложение должно выполнять несколько задач в одно и то же время, используются потоки (threads). В этом случае для ограничения доступа потоков к памяти в Python имеется блокировщик GIL.

* AsyncIO? В чём его особенность?

В отличие от потоков, в AsyncIO переключение между сопрограммами происходит лишь тогда, когда сопрограмма ожидает завершения внешней операции. 

* Что такое async/await, для чего они нужны и как их использовать?

`async`/`await` нужен для того, чтобы не блокировать поток выполнения на время ожидания какого-нибудь асинхронного события. Конструкция async/await превращает по сути процедуру в корутину (сопрограмму): она прекращает своё выполнение на время await, дожидается асинхронного события, и возобновляет работу.

* Что такое garbage collector (gc)?

Как только объекты больше не нужны, Python автоматически освобождает память из под них.

* Что такое контекстные менеджеры?

Контекстные менеджеры – это конструкции, которые упрощают работу с тем или иным интерфейсом (например, работу с файлами). Создаются они с помощью оператора **with**.
