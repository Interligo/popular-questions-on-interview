### **XPath** (на основе руководства консорциума W3C)

***

* **Что такое XPath**:

Невероятно гибкий, мощный, и вместе с тем сравнительно простой инструмент для навигации по документам XML. 
XPath использует выражения пути для выбора отдельных узлов или набора узлов в документе XML.

***

* **Терминология**:

В XPath существует семь видов узлов: элемент, атрибут, текст, пространство имён, инструкции обработки, комментарии и узлы документа. 
XML-документы обрабатываются в виде деревьев узлов. Верхний элемент дерева называется корневым элементом.

```xml
<bookstore> (корневой элемент)
<author>J. K. Rowling</author> (узел)
lang="en" (атрибут)
```

**Атомарные значения** являются узлами, не имеющие детей или родителей.

**Элементы** – это атомарные значения или узлы.

**Предок** – это родитель узла, родитель родителя узла. **Потомок** - это Дети узла, дети детей узла.
В следующем примере предки элемента «название» (title) – это элементы «книга» (book) и «книжный магазин» (bookstore), 
а потомками элемента «книжный магазин» являются элементы «книга», «название», «автор», «год» и «цена»:

```xml
<bookstore>
    <book>
        <title>Harry Potter</title>
        <author>J K. Rowling</author>
        <year>2005</year>
        <price>29.99</price>
    </book>
</bookstore>
```

Каждый элемент и атрибут имеет одного **родителя**. 
Узлы элементов могут иметь ноль, один или более **потомков** (потомки между собой считаются **элементами одного уровня**). 
В следующем примере элемент «книга» (book) является родителем элементов «название» (title), «автор» (author), «год» (year) и «цена» (price), 
а элементы «название», «автор», «год» и «цена» – они все потомки элемента книга:

```xml
<book>
    <title>Harry Potter</title>
    <author>J K. Rowling</author>
    <year>2005</year>
    <price>29.99</price>
</book>
```

***

* **Синтаксис**:

XPath использует выражения пути для выбора узлов или множества узлов в документе XML. Узел можно выбрать, следуя пути или по шагам. 

Путь определения местоположения может быть абсолютным или относительным. 
Абсолютный путь расположения начинается с косой черты (/), а относительный – нет. 
В обоих случаях путь выборки состоит из одного или нескольких шагов, разделённых косой чертой.

Самые полезные выражения пути перечислены ниже:

`имя_узла - выбирает все узлы с именем имя_узла`

`/ - выбирает от корневого узла`

`// - выбирает узлы в документе от текущего узла, который соответствует выбору, независимо от того, где они находятся`

`. - выбирает текущий узел`

`.. - выбирает родителя текущего узла`

`@ - выбирает атрибуты`

Специальные символы XPath могут использоваться для выбора неизвестных XML узлов.

`* - соответствует любому узлу`

`@* - соответствует узлу-атрибуту`

`node() - соответствует любому узлу любого типа`

**Примеры:**

`bookstore - выбирает все узлы с именем "bookstore"`

`/bookstore - выбирает корневой элемент книжного магазина`  

`bookstore/book - выбирает все элементы «книга» (book), которые являются потомками элемента «книжный магазин» (bookstore)`

`//book - выбирает все элементы «книга» независимо от того, где они находятся в документе`

`bookstore//book - выбирает все элементы «книга», которые являются потомком элемента «книжный магазин», независимо от того, где они находятся под элементом «книжный магазин»`

`//@lang - выбирает все атрибуты, которые называются "lang"`

***

* **Предикаторы**:

Предикаты используются для поиска специфического узла или узла, который содержит специфическое значение. 
Предикаты всегда обрамляются квадратными скобками. 

В приведённой ниже таблице перечислены некоторые выражения пути с предикатами, и результат выражения:

`/bookstore/book[1] - выбирает первый элемент «книга», который является потомком элемента «книжный магазин».`

`/bookstore/book[last()] - выбирает последний элемент «книга» (book), который является дочерним элементом элемента «книжный магазин» (bookstore)`

`/bookstore/book[last()-1] - выбирает предпоследний элемент «книга», который является дочерним элементом элемента «книжный магазин»`

`/bookstore/book[position()<3] - выбор первых двух элементов «книга», которые являются потомками элемента «книжный магазин»`

`//title[@lang] - выбирает все элементы «название» (title), которые имеют атрибут с именем "lang"`

`//title[@lang='en'] - выбирает все элементы «название», которые имеют атрибут «язык» со значением "en"`

`/bookstore/book[price>35.00] - выбирает все элементы «книга» после элемента «книжный магазин», которые имеют элемент «цена» со значением больше, чем 35.00`

`/bookstore/book[price>35.00]/title - выбирает все элементы «название» книги элемента «книжный магазин», которые имеют элемент «цена» со значением больше, чем 35.00`

`/bookstore/* - выбирает все дочерние узлы элемента «книжный магазин» (bookstore)`

`//* - выбирает все элементы в документе`

`//title[@*] - выбирает все элементы «название» (title), которые имеют по крайней мере один атрибут любого вида`

***

* **Выбор нескольких путей**:

С помощью оператора | в выражениях XPath вы можете выбрать несколько путей. 
В таблице ниже перечислены несколько выражений путей и результаты их применения:

`//book/title | //book/price - выбирает все элементы «название» (title) И «цена» (price) всех элементов «книга» (book)`

`//title | //price - выбирает все элементы «название» (title) И «цена» (price) в документе`

`/bookstore/book/title | //price - выбирает все элементы «название» элемента «книга» элемента «книжный магазин» И все элементы «цена» в документе`

***

* **Оси**:

Оси определяют наборы узлов, относительно текущего узла.

`ancestor - выбирает всех предков (родителей, прародителей и т.д.) текущего узла`

`ancestor-or-self - выбирает всех предков (родителей, прародителей и т.д.) текущего узла и сам текущий узел`

`attribute - выбирает все атрибуты текущего узла`

`child - выбирает всех потомков текущего узла`

`descendant - выбирает всех потомков (детей, внуков и т.д.) текущего узла`

`descendant-or-self - выбирает всех потомков (детей, внуков и т.д.) текущего узла и сам текущий узел`

`following - выбирает всё в документе после закрытия тэга текущего узла`

`following-sibling - выбирает все узлы одного уровня после текущего узла`

`namespace - выбирает все узлы в данном пространстве имён (namespace) текущего узла`

`parent - выбирает родителя текущего узла`

`preceding - выбирает все узлы, которые появляются перед текущим узлом в документе, за исключением предков, узлов атрибутов и узлы пространства имён`

`preceding-sibling - выбирает всех братьев и сестёр до текущего узла`

`self - выбирает текущий узел`

**Примеры:**

`child::book - выбирает все узлы «книга» (book), которые являются потомками текущего узла`

`attribute::lang - выбирает атрибут «язык» (lang) текущего узла`

`child::* - выбирает всех потомков текущего узла`

`attribute::* - выбирает все атрибуты текущего узла`

`child::text() - выбирает все текстовые узлы текущего узла`

`child::node() - выбирает всех ближайших потомков текущего узла`

`descendant::book - выбирает всех потомков текущего узла`

`ancestor::book - выбирает всех предков «книга» (books) текущего узла`

`ancestor-or-self::book - выбирает всех предков «книга» (book) текущего узла – и текущий узел, если он также «книга» (book)`

`child::*/child::price - выбирает все потомки «цена» (price) через один уровень от текущего узла`

***

* **Операторы:**

`| - вычисляет два набора узлов - //book | //cd`

`+ - сложение - 6 + 4`

`- - вычитание - 6 - 4`

`* - умножение - 6 * 4`

`div - деление - 8 div 4`

`= - равенство - price=9.80`

`!= - неравенство - price!=9.80`

`< - меньше, чем - price<9.80`

`<= - меньше или равно - price≤9.80`

`> - больше, чем - price>9.80`

`>= - больше или равно - price≤9.80`

`or - или - price=9.80 or price=9.70`

`and - и - price>9.00 and price<9.90`

`mod - остаток от деления - 5 mod 2`

***
